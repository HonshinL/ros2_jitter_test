要查看哪些中断正在“骚扰”你的 CPU 14，最直接的方法是查看系统的 `/proc/interrupts` 文件。这是一个实时记录系统所有硬中断分发情况的统计表。

### 1. 实时监控 CPU 14 的中断情况

你可以使用 `watch` 命令配合 `awk` 来实时观察 CPU 14 的动态：

```bash
watch -n 1 "awk 'NR==1{for(i=1;i<=NF;i++) if(\$i==\"CPU14\") col=i+1} {print \$1, \$col, \$NF}' /proc/interrupts | column -t | grep -v ' 0 '"

```

**这个命令的作用是：**

1. 锁定第 14 号核心所在的列。
2. 过滤掉计数为 **0** 的中断。
3. 剩下的就是**正在干扰 CPU 14 的硬件中断**（如网卡 `eth0`、定时器 `LOC` 或磁盘控制器）。

---

### 2. 中断是如何干扰你的？

当硬件中断发生时，内核会强制暂停 CPU 14 正在运行的 `mock_robot_driver`，转而去执行“中断处理程序”（ISR）。

* **微小抖动：** 如果只是简单的计数。
* **剧烈抖动：** 如果是频繁的网络包或磁盘 I/O 中断，你的程序会被反复切断。

---

### 3. 如何彻底将中断移出 CPU 14？

如果你发现 CPU 14 上依然有中断波动，且已经关闭了 `irqbalance`，你可以通过 **SMP Affinity**（对称多处理亲和性）进行手动“驱逐”。

每个中断都有一个 `smp_affinity_list` 文件，决定了它允许在哪些核上运行。

**一键“驱逐”脚本：**
你可以运行以下循环，将所有可移动中断的亲和性设置为“除了 CPU 14 以外的所有核心”：

```bash
# 假设你的系统有 16 个核 (0-15)
# 我们将中断限制在 0-13 核，避开 14
for irq in /proc/irq/*/smp_affinity_list; do
    echo "0-13" | sudo tee $irq > /dev/null 2>&1
done
echo "所有可移动中断已尝试移出 CPU 14"

```

---

### 总结你的实验环境检查清单：

1. **系统层**：`isolcpus=14` 是否在 GRUB 中生效？
2. **服务层**：`irqbalance` 是否已停止？
3. **硬件层**：`/proc/interrupts` 中 CPU 14 的计数是否保持静止？
4. **应用层**：是否使用了 `taskset -c 14` 和 `chrt -f 99`？

**你现在已经具备了做高精度机器人抖动测试的所有前置条件。你需要我帮你分析一下 `mock_robot_driver` 跑出来的延迟数据（比如如果是几百微秒的跳动说明了什么）吗？**